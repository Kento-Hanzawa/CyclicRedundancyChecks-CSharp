<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="T4Includes\Header.ttinclude" #>
<#@ include file="T4Includes\AlgorithmCatalog.ttinclude" #>
using System;
using System.Globalization;
using System.Numerics;

namespace CyclicRedundancyChecks.Catalogs
{
<# foreach (AlgorithmDefinition definition in AlgorithmCatalog.Definitions) { #>
    /// <summary>
    /// <para>入力データの <#= definition.Name #> ハッシュを計算します。</para>
    /// </summary>
    /// <remarks>
    /// <para>このアルゴリズムは <see cref="<#= definition.InheritClassName #>"/> に基づいており、以下のパラメータが割り当てられています。</para>
    /// <para><i>Polynomial   </i>: <b><#= definition.Poly #></b></para>
    /// <para><i>InitialValue </i>: <b><#= definition.Init #></b></para>
    /// <para><i>FinalXorValue</i>: <b><#= definition.Xorout #></b></para>
    /// <para><i>ReflectInput </i>: <b><#= definition.Refin #></b></para>
    /// <para><i>ReflectOutput</i>: <b><#= definition.Refout #></b></para>
    /// </remarks>
    public sealed class <#= definition.ClassName #> : <#= definition.InheritClassName #>
    {
        private static readonly global::<#= definition.UnderlyingType.FullName #>[] LookupTableBuffer;
        public override ReadOnlySpan<global::<#= definition.UnderlyingType.FullName #>> LookupTable { get { return LookupTableBuffer; } }

        static <#= definition.ClassName #>()
        {
<# if (definition.IsBigCRC) { #>
            Span<global::<#= definition.UnderlyingType.FullName #>> table = new global::<#= definition.UnderlyingType.FullName #>[LookupTableSize];
            LookupTableFill(table, <#= definition.Width #>, BigInteger.Parse("<#= definition.PolyValueOnly #>", NumberStyles.AllowHexSpecifier));
<# } else { #>
            Span<global::<#= definition.UnderlyingType.FullName #>> table = stackalloc global::<#= definition.UnderlyingType.FullName #>[LookupTableSize];
            LookupTableFill(table, <#= definition.Width #>, <#= definition.Poly #>);
<# } #>
            LookupTableBuffer = table.ToArray();
        }

        /// <summary>
        /// <see cref="<#= definition.ClassName #>"/> クラスの新しいインスタンスを作成します。
        /// </summary>
        /// <param name="isLookupTable">
        /// 計算用テーブルを使用する場合は <see langword="true"/>、使用しない場合は <see langword="false"/> を指定します。
        /// 使用する場合、事前に全 Byte ビットパターン (255) の計算テーブルを生成し、CRC 計算時の手順をいくつかスキップすることでパフォーマンスが向上する場合があります。
        /// しかし、テーブル生成にはコストが発生するので、インプットデータサイズが合計 255 バイト以下の場合は、テーブルを使用しない方がパフォーマンスが向上する可能性が高くなります。
        /// </param>
        /// <param name="isBigEndianResult">計算結果のCRC値をビッグエンディアン順に <see cref="byte"/> 配列に格納する場合は <see langword="true"/>、リトルエンディアン順に格納する場合は <see langword="false"/> を指定します。</param>
        public <#= definition.ClassName #>(bool isLookupTable = true, bool isBigEndianResult = false)
<# if (definition.IsBigCRC) { #>
            : base(BigInteger.Parse("<#= definition.PolyValueOnly #>", NumberStyles.AllowHexSpecifier), BigInteger.Parse("<#= definition.InitValueOnly #>", NumberStyles.AllowHexSpecifier), BigInteger.Parse("<#= definition.XoroutValueOnly #>", NumberStyles.AllowHexSpecifier), <#= definition.Refin #>, <#= definition.Refout #>, isLookupTable, isBigEndianResult)
<# } else { #>
            : base(<#= definition.Poly #>, <#= definition.Init #>, <#= definition.Xorout #>, <#= definition.Refin #>, <#= definition.Refout #>, isLookupTable, isBigEndianResult)
<# } #>
        {
        }
    }

<# } #>
}