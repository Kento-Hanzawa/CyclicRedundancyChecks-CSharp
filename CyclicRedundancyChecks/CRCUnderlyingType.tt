<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="T4Includes\Header.ttinclude" #>
<#@ include file="T4Includes\CRCClassInfo.ttinclude" #>
using System;

namespace CyclicRedundancyChecks.Underlying
{
<# foreach (IUnderlyingClassInfo info in UnderlyingClassInfo.All()) { #>
    /// <summary>
<# if (info.IsBigInteger) { #>
    /// 任意のビットサイズの CRC 値を計算する機能を提供します。
<# } else { #>
    /// 最大 <#= info.BitSize #> ビットサイズまでの CRC 値を計算する機能を提供します。
<# } #>
    /// </summary>
    public class <#= info.ClassName #> : CRC
    {
        private global::<#= info.Type.FullName #> result;
        private readonly global::<#= info.Type.FullName #> bitMask;
        private readonly int byteSize;
        private readonly global::<#= info.Type.FullName #>[] lookupTableBuffer;

        public global::<#= info.Type.FullName #> Polynomial { get; }
        public global::<#= info.Type.FullName #> InitialValue { get; }
        public global::<#= info.Type.FullName #> FinalXorValue { get; }
        public bool ReflectInput { get; }
        public bool ReflectOutput { get; }
        public bool IsBigEndianResult { get; set; }

        public ReadOnlySpan<global::<#= info.Type.FullName #>> LookupTable { get { return lookupTableBuffer.AsSpan(0, LookupTableSize); } }

        public <#= info.ClassName #>(int bitWidth, global::<#= info.Type.FullName #> polynomial, global::<#= info.Type.FullName #> initialValue, global::<#= info.Type.FullName #> finalXorValue, bool reflectInput, bool reflectOutput, bool isBigEndianResult = false)
        {
<# if (!info.IsBigInteger) { #>
            const int MaxBitWidth = sizeof(global::<#= info.Type.FullName #>) * 8;
            if (MaxBitWidth < bitWidth)
            {
                bitWidth = MaxBitWidth;
            }

<# } #>
            this.HashSizeValue = bitWidth;

            this.result = initialValue;
<# if (info.IsBigInteger) { #>
            this.bitMask = (global::<#= info.Type.FullName #>)(((global::<#= info.Type.FullName #>)1 << bitWidth) - 1);
            this.byteSize = (HashSizeValue / 8) + (HashSizeValue % 8 == 0 ? 0 : 1);
<# } else { #>
            this.bitMask = (bitWidth == MaxBitWidth) ? (global::<#= info.Type.FullName #>)0x<#= new string('F', info.ByteSize * 2) #> : (global::<#= info.Type.FullName #>)(((global::<#= info.Type.FullName #>)1 << bitWidth) - 1);
            this.byteSize = sizeof(global::<#= info.Type.FullName #>);
<# } #>
            this.lookupTableBuffer = System.Buffers.ArrayPool<global::<#= info.Type.FullName #>>.Shared.Rent(LookupTableSize);

            this.Polynomial = polynomial;
            this.InitialValue = initialValue;
            this.FinalXorValue = finalXorValue;
            this.ReflectInput = reflectInput;
            this.ReflectOutput = reflectOutput;
            this.IsBigEndianResult = isBigEndianResult;

            LookupTableFill();
        }

        public override void Initialize()
        {
            result = InitialValue;
        }

        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            HashCore(array.AsSpan(ibStart, cbSize));
        }

        protected override void HashCore(ReadOnlySpan<byte> source)
        {
            for (var i = 0; i < source.Length; i++)
            {
                if (ReflectInput)
                {
                    var tableIndex = (int)((result ^ source[i]) & 0xFF);
                    result = (global::<#= info.Type.FullName #>)((result >> 8) ^ LookupTable[tableIndex]);
                }
                else
                {
                    var tableIndex = (int)(((result >> (HashSizeValue - 8)) ^ source[i]) & 0xFF);
                    result = (global::<#= info.Type.FullName #>)((result << 8) ^ LookupTable[tableIndex]);
                }
            }
        }

        protected override byte[] HashFinal()
        {
            Span<byte> span = stackalloc byte[byteSize];
            TryHashFinal(span, out _);
            return span.ToArray();
        }

        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < byteSize)
            {
                bytesWritten = 0;
                return false;
            }
           
            if (ReflectInput)
            {
                result = CRCUtility.BitReflect(result, HashSizeValue);
            }
            if (ReflectOutput)
            {
                result = CRCUtility.BitReflect(result, HashSizeValue);
            }
            result ^= FinalXorValue;
            result = (global::<#= info.Type.FullName #>)(result & bitMask);

<# if (info.IsBigInteger) { #>
            return result.TryWriteBytes(destination, out bytesWritten, true, IsBigEndianResult);
<# } else { #>
            for (var i = 0; i < byteSize; i++)
            {
                if (IsBigEndianResult)
                {
                    destination[i] = (byte)(result >> (HashSizeValue - ((i * 8) + 8)));
                }
                else
                {
                    destination[i] = (byte)(result >> (i * 8));
                }
            }
            bytesWritten = byteSize;
            return true;
<# } #>
        }

        private void LookupTableFill()
        {
            var polynomial = ReflectInput ? CRCUtility.BitReflect(Polynomial, HashSizeValue) : Polynomial;

            for (int i = 0; i < LookupTableSize; i++)
            {
                lookupTableBuffer[i] = Obtener((byte)(i & 0xFF));
            }

            global::<#= info.Type.FullName #> Obtener(byte position)
            {
                global::<#= info.Type.FullName #> result;
                if (ReflectInput)
                {
                    result = (global::<#= info.Type.FullName #>)position;
                    for (var i = 0; i < 8; i++)
                    {
                        if ((result & 1) == 0)
                        {
                            result = (global::<#= info.Type.FullName #>)(result >> 1);
                        }
                        else
                        {
                            result = (global::<#= info.Type.FullName #>)((result >> 1) ^ polynomial);
                        }
                    }
                }
                else
                {
                    global::<#= info.Type.FullName #> TopBit = (global::<#= info.Type.FullName #>)((global::<#= info.Type.FullName #>)1 << (HashSizeValue - 1));
                    result = (global::<#= info.Type.FullName #>)((global::<#= info.Type.FullName #>)position << (HashSizeValue - 8));
                    for (var i = 0; i < 8; i++)
                    {
                        if ((result & TopBit) == 0)
                        {
                            result = (global::<#= info.Type.FullName #>)(result << 1);
                        }
                        else
                        {
                            result = (global::<#= info.Type.FullName #>)((result << 1) ^ polynomial);
                        }
                    }
                }
                return result;
            }
        }

        #region IDisposable
        private bool disposedValue = false;
        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if (lookupTableBuffer != null)
                    {
                        System.Buffers.ArrayPool<global::<#= info.Type.FullName #>>.Shared.Return(lookupTableBuffer);
                    }
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }
        #endregion
    }

<# } #>
}
