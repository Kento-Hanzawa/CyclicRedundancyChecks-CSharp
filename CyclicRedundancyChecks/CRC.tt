<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="CRC.ttinclude" #>
using System;

namespace CyclicRedundancyChecks
{
    /// <summary>
    /// CRC (Cyclic Redundancy Check) のすべての実装が継承する必要のある抽象基底クラスを表します。
    /// </summary>
    public abstract partial class CRC : System.Security.Cryptography.HashAlgorithm
    {
        protected const int TableSize = 256;

        public static void RegisterAlgorithm()
        {
            // CRC8
<# foreach (var info in CRC8Infos) { #>
            System.Security.Cryptography.CryptoConfig.AddAlgorithm(typeof(global::CyclicRedundancyChecks.<#= info.ClassName #>), "<#= info.CRCName #>");
<# } #>
            // CRC16
<# foreach (var info in CRC16Infos) { #>
            System.Security.Cryptography.CryptoConfig.AddAlgorithm(typeof(global::CyclicRedundancyChecks.<#= info.ClassName #>), "<#= info.CRCName #>");
<# } #>
            // CRC32
<# foreach (var info in CRC32Infos) { #>
            System.Security.Cryptography.CryptoConfig.AddAlgorithm(typeof(global::CyclicRedundancyChecks.<#= info.ClassName #>), "<#= info.CRCName #>");
<# } #>
            // CRC64
<# foreach (var info in CRC64Infos) { #>
            System.Security.Cryptography.CryptoConfig.AddAlgorithm(typeof(global::CyclicRedundancyChecks.<#= info.ClassName #>), "<#= info.CRCName #>");
<# } #>
        }
    }

<# foreach (var info in CRCRegulations) { #>
    /// <summary>
    /// 入力データの <see cref="CyclicRedundancyChecks.<#= info.CRCName #>"/> ハッシュを計算します。
    /// </summary>
    public class <#= info.CRCName #> : CRC
    {
        private const int ByteSize = sizeof(global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>);
        private const int BitSize = ByteSize * 8;

        public global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> result;
        private readonly global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>[] lookupTableBuffer;

        public global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> Polynomial { get; }
        public global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> InitialValue { get; }
        public global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> FinalXorValue { get; }
        public bool ReversedData { get; }
        public bool ReversedOut { get; }
        public ReadOnlySpan<global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>> LookupTable { get { return lookupTableBuffer.AsSpan(0, TableSize); } }

        public <#= info.CRCName #>(global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> polynomial, global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> initialValue, global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #> finalXorValue, bool reversedData, bool reversedOut)
        {
            this.HashSizeValue = BitSize;

            this.result = initialValue;
            this.lookupTableBuffer = System.Buffers.ArrayPool<global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>>.Shared.Rent(TableSize);
            this.Polynomial = polynomial;
            this.InitialValue = initialValue;
            this.FinalXorValue = finalXorValue;
            this.ReversedData = reversedData;
            this.ReversedOut = reversedOut;

            CRCUtility.TableFill(lookupTableBuffer.AsSpan(0, TableSize), Polynomial, reversedData);
        }

        public override void Initialize()
        {
            result = InitialValue;
        }

        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            HashCore(array.AsSpan(ibStart, cbSize));
        }

        protected override void HashCore(ReadOnlySpan<byte> source)
        {
            for (var i = 0; i < source.Length; i++)
            {
                if (ReversedData)
                {
                    var tableIndex = (int)((result ^ source[i]) & 0xFF);
                    result = (global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>)((result >> 8) ^ LookupTable[tableIndex]);
                }
                else
                {
                    var tableIndex = (int)(((result >> (BitSize - 8)) ^ source[i]) & 0xFF);
                    result = (global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>)((result << 8) ^ LookupTable[tableIndex]);
                }
            }
        }

        protected override byte[] HashFinal()
        {
            Span<byte> span = stackalloc byte[ByteSize];
            TryHashFinal(span, out _);
            return span.ToArray();
        }

        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < ByteSize)
            {
                bytesWritten = 0;
                return false;
            }

            // 参考にしたコードでこういった記述があるが、
            // この条件が true になることはなさそうです。
            if ((sizeof(global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>) * 8) > BitSize)
            {
                result = (global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>)(result & ((global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>)1 << BitSize) - 1);
            }

            if (ReversedData)
                result = CRCUtility.BitReverse(result);
            if (ReversedOut)
                result = CRCUtility.BitReverse(result);
            result ^= FinalXorValue;

<# for (var i = 0; i < info.ByteSize; i++) { #>
            destination[<#= i #>] = (byte)(result >> <#= 8 * i #>);
<# } #>
            bytesWritten = ByteSize;
            return true;
        }

        #region IDisposable
        private bool disposedValue = false;
        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if (lookupTableBuffer != null)
                        System.Buffers.ArrayPool<global::<#= info.CRCType.Namespace #>.<#= info.CRCType.Name #>>.Shared.Return(lookupTableBuffer);
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }
        #endregion
    }

<# } #>
}
