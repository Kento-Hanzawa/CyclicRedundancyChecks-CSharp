<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="T4Includes\Header.ttinclude" #>
<#@ include file="T4Includes\CRCClassInfo.ttinclude" #>
using System;

namespace CyclicRedundancyChecks.UnderlyingTypes
{
<# foreach (IUnderlyingClassInfo info in UnderlyingClassInfo.All()) { #>
    /// <summary>
<# if (info.IsBigInteger) { #>
    /// 任意のビットサイズの CRC 値を計算する機能を提供します。
<# } else { #>
    /// 最大 <#= info.BitSize #> ビットサイズまでの CRC 値を計算する機能を提供します。
<# } #>
    /// </summary>
    public class <#= info.ClassName #> : CRC
    {
        private global::<#= info.Type.FullName #> result;
        private global::<#= info.Type.FullName #>[] lookupTableBuffer;

        private readonly global::<#= info.Type.FullName #> bitMask;
        private readonly int byteSize;

        public global::<#= info.Type.FullName #> Polynomial { get; }
        public global::<#= info.Type.FullName #> InitialValue { get; }
        public global::<#= info.Type.FullName #> FinalXorValue { get; }
        public bool ReflectInput { get; }
        public bool ReflectOutput { get; }
        public bool IsLookupTable { get; set; }
        public bool IsBigEndianResult { get; set; }

        public virtual ReadOnlySpan<global::<#= info.Type.FullName #>> LookupTable
        {
            get
            {
                if (lookupTableBuffer == null)
                {
                    lookupTableBuffer = System.Buffers.ArrayPool<global::<#= info.Type.FullName #>>.Shared.Rent(LookupTableSize);
                    LookupTableFill(lookupTableBuffer, HashSizeValue, Polynomial);
                }
                return lookupTableBuffer.AsSpan(0, LookupTableSize);
            } 
        }



        public <#= info.ClassName #>(int bitWidth, global::<#= info.Type.FullName #> polynomial, global::<#= info.Type.FullName #> initialValue, global::<#= info.Type.FullName #> finalXorValue, bool reflectInput, bool reflectOutput, bool isLookupTable = true, bool isBigEndianResult = false)
        {
<# if (!info.IsBigInteger) { #>
            const int MaxBitWidth = sizeof(global::<#= info.Type.FullName #>) * 8;
            bitWidth = Math.Clamp(bitWidth, 0, MaxBitWidth);
<# } #>

            this.HashSizeValue = bitWidth;
            this.Polynomial = polynomial;
            this.InitialValue = initialValue;
            this.FinalXorValue = finalXorValue;
            this.ReflectInput = reflectInput;
            this.ReflectOutput = reflectOutput;
            this.IsLookupTable = isLookupTable;
            this.IsBigEndianResult = isBigEndianResult;

            this.result = initialValue;
<# if (info.IsBigInteger) { #>
            this.bitMask = (global::<#= info.Type.FullName #>)(((global::<#= info.Type.FullName #>)1U << bitWidth) - 1);
            this.byteSize = (HashSizeValue / 8) + (HashSizeValue % 8 == 0 ? 0 : 1);
<# } else { #>
            this.bitMask = (bitWidth == MaxBitWidth) ? (global::<#= info.Type.FullName #>)0x<#= new string('F', info.ByteSize * 2) #> : (global::<#= info.Type.FullName #>)(((global::<#= info.Type.FullName #>)1 << bitWidth) - 1);
            this.byteSize = sizeof(global::<#= info.Type.FullName #>);
<# } #>
        }



        public override void Initialize()
        {
            result = InitialValue;
        }



        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            HashCore(array.AsSpan(ibStart, cbSize));
        }

        protected override void HashCore(ReadOnlySpan<byte> source)
        {
            if (IsLookupTable)
            {
                Calculate(ref result, source, HashSizeValue, LookupTable, ReflectInput);
            }
            else
            {
                Calculate(ref result, source, HashSizeValue, Polynomial, ReflectInput);
            }
        }



        protected override byte[] HashFinal()
        {
            Span<byte> span = stackalloc byte[byteSize];
            TryHashFinal(span, out _);
            return span.ToArray();
        }

        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < byteSize)
            {
                bytesWritten = 0;
                return false;
            }
           
            if (ReflectOutput)
            {
                result = CRCUtility.BitReflect(result, HashSizeValue);
            }
            result ^= FinalXorValue;
            result = (global::<#= info.Type.FullName #>)(result & bitMask);

<# if (info.IsBigInteger) { #>
            return result.TryWriteBytes(destination, out bytesWritten, true, IsBigEndianResult);
<# } else { #>
            for (var i = 0; i < byteSize; i++)
            {
                if (IsBigEndianResult)
                {
                    destination[i] = (byte)(result >> ((byteSize * 8) - ((i * 8) + 8)));
                }
                else
                {
                    destination[i] = (byte)(result >> (i * 8));
                }
            }
            bytesWritten = byteSize;
            return true;
<# } #>
        }



        protected static void LookupTableFill(Span<global::<#= info.Type.FullName #>> table, in int bitWidth, global::<#= info.Type.FullName #> polynomial)
        {
            for (int i = 0; i < LookupTableSize; i++)
            {
                byte dividend = (byte)(i & byte.MaxValue);
                table[i] = PolynomialDivRem(dividend, bitWidth, polynomial);
            }
        }



        private static void Calculate(ref global::<#= info.Type.FullName #> crc, in ReadOnlySpan<byte> bytes, in int bitWidth, in global::<#= info.Type.FullName #> polynomial, in bool reflectInput)
        {
            const int InputBits = sizeof(byte) * 8;
            for (var i = 0; i < bytes.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(bytes[i]) : bytes[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (InputBits - bitWidth)) & byte.MaxValue;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - InputBits)) & byte.MaxValue;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::<#= info.Type.FullName #> remainder = PolynomialDivRem(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::<#= info.Type.FullName #>)((crc << InputBits) ^ remainder);
            }
        }

        private static void Calculate(ref global::<#= info.Type.FullName #> crc, in ReadOnlySpan<byte> bytes, in int bitWidth, in ReadOnlySpan<global::<#= info.Type.FullName #>> table, in bool reflectInput)
        {
            const int InputBits = sizeof(byte) * 8;
            for (var i = 0; i < bytes.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(bytes[i]) : bytes[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (InputBits - bitWidth)) & byte.MaxValue;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - InputBits)) & byte.MaxValue;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::<#= info.Type.FullName #> remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::<#= info.Type.FullName #>)((crc << InputBits) ^ remainder);
            }
        }



        private static global::<#= info.Type.FullName #> PolynomialDivRem(in byte dividend, in int bitWidth, global::<#= info.Type.FullName #> polynomial)
        {
            const int InputBits = sizeof(byte) * 8; // dividend のサイズ。

            if (bitWidth < 8)
            {
                // remainder: aaaa bbbb
                global::<#= info.Type.FullName #> remainder = (global::<#= info.Type.FullName #>)dividend;
                // polynomial の先頭ビット (bitWidth の位置) が、remainder の先頭ビット (8) に合うようにシフト演算します。
                // polynomial: 0aaa bbbb (7ビット以下)
                // polynomial: aaab bbb0
                polynomial = (global::<#= info.Type.FullName #>)(polynomial << (InputBits - bitWidth));

                // remainder の先頭ビットが 0 の場合は remainder を 1 だけ左シフト、
                // 1 の場合は remainder を 1 だけ左シフトした後に polynomial と XOR 演算します。
                // これを dividend のビット長分だけ繰り返して剰余を計算します。
                // dividend: aaaa bbbb
                //           ^ (ここを見る)
                const int LoopCount = InputBits;
                for (int i = 0; i < LoopCount; i++)
                {
                    global::<#= info.Type.FullName #> TopBit = (global::<#= info.Type.FullName #>)(0x80);
                    if ((remainder & TopBit) == 0)
                    {
                        remainder <<= 1;
                    }
                    else
                    {
                        remainder <<= 1;
                        remainder ^= polynomial;
                    }
                }

                // 最初に polynomial をシフトした影響で、remainder の値が左に寄った感じになっています。
                // remainder: aaab bbb0
                // なので、polynomial のシフトと逆方向に同じ分だけシフトし直して、正しい位置に戻します。
                // remainder: 0aaa bbbb
                return (global::<#= info.Type.FullName #>)(remainder >> (InputBits - bitWidth));
            }
            else
            {
                // dividend の先頭ビット位置を polynomial の先頭ビット (bitWidth の位置) に合わせます。
                // polynomial: 00aa bbbb cccc ... yyyy zzzz
                // dividend  :                    aaaa bbbb
                // dividend  :   aa aabb bb00 ... 0000 0000
                global::<#= info.Type.FullName #> remainder = (global::<#= info.Type.FullName #>)((global::<#= info.Type.FullName #>)dividend << (bitWidth - InputBits));

                // remainder の先頭ビットが 0 の場合は remainder を 1 だけ左シフト、
                // 1 の場合は remainder を 1 だけ左シフトした後に polynomial と XOR 演算します。
                // これを dividend のビット長分だけ繰り返して剰余を計算します。
                // dividend: aaaa bbbb
                //           ^ (ここを見る)
                const int LoopCount = InputBits;
                for (int i = 0; i < LoopCount; i++)
                {
                    global::<#= info.Type.FullName #> TopBit = (global::<#= info.Type.FullName #>)((global::<#= info.Type.FullName #>)1U << (bitWidth - 1));

                    if ((remainder & TopBit) == 0)
                    {
                        remainder <<= 1;
                    }
                    else
                    {
                        remainder <<= 1;
                        remainder ^= polynomial;
                    }
                }

                return remainder;
            }
        }



        #region IDisposable

        private bool disposedValue = false;

        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if (lookupTableBuffer != null)
                    {
                        System.Buffers.ArrayPool<global::<#= info.Type.FullName #>>.Shared.Return(lookupTableBuffer);
                    }
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }

        #endregion
    }

<# } #>
}
