<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ Assembly Name="System.Numerics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Numerics" #>
<#@ output extension=".cs" #>
<# 
    Type[] types =
    {
        typeof(byte),
        typeof(ushort),
        typeof(uint),
        typeof(ulong),
        typeof(BigInteger),
    };
#>
// <auto-generated>
// この .cs ファイルはT4によって自動的に生成されています。直接編集はせず、代わりに .tt ファイルを編集してください。
// </auto-generated>

namespace CyclicRedundancyChecks.Internal
{
<# foreach (var type in types) { #>
    partial class CRCUtility
    {
        public static global::<#= type.FullName #> RemainderByPolynomial(in byte dividend, in int bitWidth, in global::<#= type.FullName #> polynomial)
        {
            const int byteSizeInBits = sizeof(byte) * 8; // dividend のサイズ。

            if (bitWidth < 8)
            {
                // remainder: aaaa bbbb
                global::<#= type.FullName #> remainder = (global::<#= type.FullName #>)dividend;

                // remainder の先頭ビットが 0 の場合は remainder を 1 だけ左シフト、
                // 1 の場合は remainder を 1 だけ左シフトした後に polynomial と XOR 演算します。
                // これを dividend のビット長分だけ繰り返して剰余を計算します。
                // dividend: aaaa bbbb
                //           ^ (ここを見る)
                for (int i = 0; i < byteSizeInBits; i++)
                {
                    global::<#= type.FullName #> topBit = (global::<#= type.FullName #>)(0x80);

                    if ((remainder & topBit) == 0)
                    {
                        remainder <<= 1;
                    }
                    else
                    {
                        remainder <<= 1;
                        // polynomial の先頭ビット (bitWidth の位置) が、remainder の先頭ビット (8) に合うようにシフト演算します。
                        // polynomial: 0aaa bbbb (7ビット以下)
                        // polynomial: aaab bbb0
                        remainder ^= (global::<#= type.FullName #>)(polynomial << (byteSizeInBits - bitWidth));
                    }
                }

                // 最初に polynomial をシフトした影響で、remainder の値が左に寄った感じになっています。
                // remainder: aaab bbb0
                // なので、polynomial のシフトと逆方向に同じ分だけシフトし直して、正しい位置に戻します。
                // remainder: 0aaa bbbb
                return (global::<#= type.FullName #>)(remainder >> (byteSizeInBits - bitWidth));
            }
            else
            {
                // dividend の先頭ビット位置を polynomial の先頭ビット (bitWidth の位置) に合わせます。
                // polynomial: 00aa bbbb cccc ... yyyy zzzz
                // dividend  :                    aaaa bbbb
                // dividend  :   aa aabb bb00 ... 0000 0000
                global::<#= type.FullName #> remainder = (global::<#= type.FullName #>)((global::<#= type.FullName #>)dividend << (bitWidth - byteSizeInBits));

                // remainder の先頭ビットが 0 の場合は remainder を 1 だけ左シフト、
                // 1 の場合は remainder を 1 だけ左シフトした後に polynomial と XOR 演算します。
                // これを dividend のビット長分だけ繰り返して剰余を計算します。
                // dividend: aaaa bbbb
                //           ^ (ここを見る)
                for (int i = 0; i < byteSizeInBits; i++)
                {
                    global::<#= type.FullName #> topBit = (global::<#= type.FullName #>)((global::<#= type.FullName #>)1UL << (bitWidth - 1));

                    if ((remainder & topBit) == 0)
                    {
                        remainder <<= 1;
                    }
                    else
                    {
                        remainder <<= 1;
                        remainder ^= polynomial;
                    }
                }

                return remainder;
            }
        }
    }

<# } #>
}
