<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ Assembly Name="System.Numerics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Numerics" #>
<#@ output extension=".cs" #>
<# 
    Type[] types =
    {
        typeof(byte),
        typeof(ushort),
        typeof(uint),
        typeof(ulong),
        typeof(BigInteger),
    };
#>
// <auto-generated>
// この .cs ファイルはT4によって自動的に生成されています。直接編集はせず、代わりに .tt ファイルを編集してください。
// </auto-generated>

namespace CyclicRedundancyChecks.Internal
{
<# foreach (var type in types) { #>
    partial class CRCUtility
    {
        public static void AppendData(ref global::<#= type.FullName #> crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in global::<#= type.FullName #> polynomial, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::<#= type.FullName #> remainder = RemainderByPolynomial(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::<#= type.FullName #>)((crc << byteSizeInBits) ^ remainder);
            }
        }

        public static void AppendData(ref global::<#= type.FullName #> crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in System.ReadOnlySpan<global::<#= type.FullName #>> table, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::<#= type.FullName #> remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::<#= type.FullName #>)((crc << byteSizeInBits) ^ remainder);
            }
        }
    }

<# } #>
}
