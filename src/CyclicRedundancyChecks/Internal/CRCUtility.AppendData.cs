// <auto-generated>
// この .cs ファイルはT4によって自動的に生成されています。直接編集はせず、代わりに .tt ファイルを編集してください。
// </auto-generated>

namespace CyclicRedundancyChecks.Internal
{
    partial class CRCUtility
    {
        public static void AppendData(ref global::System.Byte crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in global::System.Byte polynomial, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.Byte remainder = RemainderByPolynomial(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.Byte)((crc << byteSizeInBits) ^ remainder);
            }
        }

        public static void AppendData(ref global::System.Byte crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in System.ReadOnlySpan<global::System.Byte> table, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.Byte remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.Byte)((crc << byteSizeInBits) ^ remainder);
            }
        }
    }

    partial class CRCUtility
    {
        public static void AppendData(ref global::System.UInt16 crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in global::System.UInt16 polynomial, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.UInt16 remainder = RemainderByPolynomial(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.UInt16)((crc << byteSizeInBits) ^ remainder);
            }
        }

        public static void AppendData(ref global::System.UInt16 crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in System.ReadOnlySpan<global::System.UInt16> table, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.UInt16 remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.UInt16)((crc << byteSizeInBits) ^ remainder);
            }
        }
    }

    partial class CRCUtility
    {
        public static void AppendData(ref global::System.UInt32 crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in global::System.UInt32 polynomial, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.UInt32 remainder = RemainderByPolynomial(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.UInt32)((crc << byteSizeInBits) ^ remainder);
            }
        }

        public static void AppendData(ref global::System.UInt32 crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in System.ReadOnlySpan<global::System.UInt32> table, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.UInt32 remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.UInt32)((crc << byteSizeInBits) ^ remainder);
            }
        }
    }

    partial class CRCUtility
    {
        public static void AppendData(ref global::System.UInt64 crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in global::System.UInt64 polynomial, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.UInt64 remainder = RemainderByPolynomial(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.UInt64)((crc << byteSizeInBits) ^ remainder);
            }
        }

        public static void AppendData(ref global::System.UInt64 crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in System.ReadOnlySpan<global::System.UInt64> table, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.UInt64 remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.UInt64)((crc << byteSizeInBits) ^ remainder);
            }
        }
    }

    partial class CRCUtility
    {
        public static void AppendData(ref global::System.Numerics.BigInteger crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in global::System.Numerics.BigInteger polynomial, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.Numerics.BigInteger remainder = RemainderByPolynomial(dividend, bitWidth, polynomial);
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.Numerics.BigInteger)((crc << byteSizeInBits) ^ remainder);
            }
        }

        public static void AppendData(ref global::System.Numerics.BigInteger crc, in System.ReadOnlySpan<byte> data, in int bitWidth, in System.ReadOnlySpan<global::System.Numerics.BigInteger> table, in bool reflectInput)
        {
            const int byteSizeInBits = sizeof(byte) * 8;

            for (var i = 0; i < data.Length; i++)
            {
                var input = reflectInput ? CRCUtility.BitReflect(data[i]) : data[i];

                // crc と input を、元々一つの連続したデータとして計算したときと同じ結果になるようにマージします。
                byte dividend;
                if (bitWidth < 8)
                {
                    // input: aaaa bbbb (8ビット)
                    // crc  : 0aaa bbbb (7ビット以下)
                    // crc  : aaab bbb0 (ビット全体を左詰めする)
                    var leftJustified = (crc << (byteSizeInBits - bitWidth)) & (byte)0xFF;
                    // aaaa bbbb ^ aaab bbb0 (XOR!)
                    dividend = (byte)(leftJustified ^ input);
                }
                else
                {
                    // input:               aaaa bbbb (8ビット)
                    // crc  : aaaa bbbb ... yyyy zzzz (8ビット以上)
                    // crc  : aaaa bbbb (先頭 8 ビットを抽出)
                    var top8 = (crc >> (bitWidth - byteSizeInBits)) & (byte)0xFF;
                    // aaaa bbbb ^ aaaa bbbb (XOR!)
                    dividend = (byte)(top8 ^ input);
                }

                // 先頭 8 ビットを除去するように左へビットシフトし、PolynomialDivRem で得られた剰余と XOR 演算します。
                // この値が現在の input までの CRC となります。これをデータの長さ分繰り返します。
                // crc      : aaaa bbbb cccc ... xxxx yyyy zzzz
                // crc      : cccc dddd eeee ... zzzz 0000 0000 ( << 8 )
                // remainder: aaaa bbbb cccc ... xxxx yyyy zzzz (剰余。長さは crc と同じ)
                global::System.Numerics.BigInteger remainder = table[dividend];
                // cccc dddd eeee ... zzzz 0000 0000 ^ aaaa bbbb cccc ... xxxx yyyy zzzz (XOR!)
                crc = (global::System.Numerics.BigInteger)((crc << byteSizeInBits) ^ remainder);
            }
        }
    }

}
